from django.core.exceptions   import ObjectDoesNotExist
from django.db   import models
from datetime    import datetime, timedelta

from utilities.TimeAgent import adjustDateTimeTz
from User        import User
from Project     import Project
from Repeat      import Repeat

class Blackout(models.Model):
    #user         = models.ForeignKey(User)
    user         = models.ForeignKey(User, null = True)
    project      = models.ForeignKey(Project, null = True)
    start_date   = models.DateTimeField(null = True, blank = True)
    end_date     = models.DateTimeField(null = True, blank = True)
    repeat       = models.ForeignKey(Repeat)
    until        = models.DateTimeField(null = True, blank = True)
    description  = models.CharField(null = True, max_length = 1024, blank = True)

    def __unicode__(self):
        return "%s Blackout for %s: %s - %s" % \
               (self.repeat.repeat, self.forName(), self.start_date, self.end_date)

    def checkValidUser(self):
        assert ((self.project is not None) or (self.user is not None))
        assert (not ((self.project is None) and (self.user is None)))
    
    def forUser(self):
        "Assumes one of [user,project] is NULL"
        self.checkValidUser()
        return self.project is None

    def forUrlId(self):
        "Returns the url id for whom this blackout is for"
        return self.user.id if self.forUser() else self.project.pcode  

    def forName(self):
        """
        Returns the name for whom this blackout is for:
           * user - display name
           * project - pcode
        """
        return self.user.display_name() if self.forUser() else self.project.pcode  

    def isActive(self, date = datetime.utcnow()):
        """
        Takes a UTC datetime object and returns a Boolean indicating whether
        this blackout's effective date range is effective on this date.
        """

        if self.start_date is None:
            return False # Never started, not active
        
        if self.repeat.repeat == "Once" and self.end_date and self.end_date <= date:
            return False # Done

        if self.start_date >= date:
            return True # Happens in the future

        if not self.end_date and self.start_date <= date:
            return True # Started on/before date, never ends

        if self.start_date <= date and self.end_date >= date:
            return True # Starts on/before date, ends on/after date

        if self.repeat.repeat != "Once":
            if not self.until and self.start_date <= date:
                return True # Started on/before date, repeats forever

            if self.until and self.until >= date and self.start_date <= date:
                return True # Started on/before date, repeats on/after date

        return False

    def generateDates(self, calstart, calend):
        """
        Takes two UTC datetimes representing a period of time on the calendar.
        Returns a list of (datetime, datetime) tuples representing all the
        events generated by this blackout in that period.
        """
        start       = self.start_date
        end         = self.end_date
        until       = min(self.until, calend) if self.until else calend
        periodicity = self.repeat.repeat

        # take care of simple scenarios first
        if start is None or end is None:
            return [] # What does it mean to have None in start or end?

        # see what other conditions we can reject
        if periodicity == "Once":
            if (start > calend or end < calstart):
                return [] # Outside time period - hasn't started or already done
        else:    
            if (start > calend or end < calstart) and until < calstart:
                return [] # Outside time period - hasn't started or already done

        dates = []
        
        def dealWithYearlyWrapAround(dt):
            if dt.month == 12: # Yearly wrap around
                month = 1; year = dt.year + 1
            else:
                month = dt.month + 1
                year  = dt.year
            return month, year

        if periodicity == "Once":
            dates.append((start, end))
        elif periodicity == "Weekly":
            while start <= until:
                if start >= calstart:
                    dates.append((start, end))

                start = start + timedelta(days = 7)
                end   = end   + timedelta(days = 7)
        elif periodicity == "Monthly":
            while start <= until:
                if start >= calstart:
                    dates.append((start, end))

                month, year = dealWithYearlyWrapAround(start)
                start = datetime(year   = year
                               , month  = month
                               , day    = start.day
                               , hour   = start.hour
                               , minute = start.minute)
                month, year = dealWithYearlyWrapAround(end)
                end   = datetime(year   = year
                               , month  = month
                               , day    = end.day
                               , hour   = end.hour
                               , minute = end.minute)
        return dates

    def eventjson(self, calstart, calend, id = None, tz = None):
        calstart = datetime.fromtimestamp(float(calstart))
        calend   = datetime.fromtimestamp(float(calend))
        dates    = self.generateDates(calstart, calend)
        if tz is not None:
            dates = [(adjustDateTimeTz(tz, s), adjustDateTimeTz(tz, e)) for s, e in dates]
        title    = "%s: %s" % (self.forName() #self.user.name()
                             , self.description or "blackout")
        return [{
            "id"   :      self.id
          , "title":      title
          , "start":      d[0].isoformat() if d[0] else None
          , "end"  :      d[1].isoformat() if d[1] else None
          , "className": 'blackout'
        } for d in dates]

    class Meta:
        db_table  = "blackouts"
        app_label = "scheduler"

