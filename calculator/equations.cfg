[equations]
min_topo_freq          = getMinTopoFreq(backend, bandwidth, windows) if mode.lower() == "spectral line" else ""
bandwidth              =
windows                =
backend                =
mode                   =
units                  =
semester               =
conversion             =
sensitivity            =
time                   =

topo_freq              = rest_freq / (1 + redshift) if doppler == "redshift" else rest_freq * (1 - source_velocity / c) if doppler == "radio" else rest_freq / (1 + source_velocity / c) if doppler == "optical" else rest_freq * math.sqrt(1 - math.pow(source_velocity / c, 2)) / ((1 + source_velocity) / c) 
dual_pol               = 2 if average_pol else 1
airmass                = 57.29 * math.log(math.tan(Elev_max/2)/math.tan(Elev_min/2))/(Elev_max - Elev_min)
attenuation            = (est0 * math.sqrt((efficiency_track * efficiency_surf)/efficiency_DSS) + (tATM - tCMB))/(tRCVR + tSpill + tATM)
elev_max               = declination + 51.57
confusionLimit         = confusionLimitS
confusionLimitS        = 0.13 * (math.pow(fwhm,2) / math.pow(frequency,0.7))
confusionLimitTA       = 0.41 * (efficiency * math.pow(DishRadius*fwhm,2))/(2 * k_boltz * math.pow(frequency,0.7) * attenuation )
distanceRef            = 2 * math.sqrt(math.pow(h,2)+math.pow(v,2))
est                    = tSys * attenuation
est0                   = ((tRCVR) + (tSpill) + (tATM) )* math.exp(tau_0)-((tATM)-(tCMB))
estTS                  = ((tBG + tGalBG)/ math.sqrt(efficiency)) +(est0/math.sqrt(efficiency_DSS))
f_vOversample          = 257830/(dv*DishRadius * topo_freq)
f_hOversample          = 257830/(dv*DishRadius * topo_freq)
k_boltz                = 1.3806503 * math.pow(10,-23)
nRefSmthAvrg           = nAvrgRef * bwRef/bw
n_uncorr_samp          = dual_pol * observing_method * sensitivity_n_overlap
level                  = 9 if bandwidth == 50 and bandwidthByWindows >= 0.38 and backend == "ACS" or bandwidth == 12.5 and bandwidthByWindows>= 1.52 and backend == "ACS" else 3
sensitivityS_withRef   = ((2*k_boltz*k1*estTS)/(efficiency*math.pi*math.pow(DishRadius,2))*math.sqrt(((RSigRef+nRefSmthAvrg )*(RSigRef +1))/(k2*math.pow(10,6)*bw*n_uncorr_samp*RSigRef*nRefSmthAvrg*tTotal)))
samp                   = DishRadius *2
tSys                   = (estTS * efficiency_track * efficiency_surf)/attenuation
tEffTA                 = math.pow(((k1 * tSys)/sensitivityTA),2)*(1/(k2*math.pow(10,6)*bw*n_uncorr_samp))
tEff                   = (tSig*(nRefSmthAvrg*tRef))/(tSig+(nRefSmthAvrg*tRef))
tSig                   = tTotal * RSigRef/(RSigRef+1)
tRef                   = tTotal/(RSigRef+1)
tMapMove               = math.max(15,12+(3 * Distance))
tCMB                   = 2.7
tSpill                 = 3
H                      = h / math.cos(vCenter)
h                      = H * math.cos(vCenter)
DishRadius             = 50
efficiency             = aperture_efficiency * f_size
f_size                 = 1/(1+math.pow((size/fwhm),2))
#k1                     = 1.032 if bandwidth == 50 and bandwidthByWindows >= 0.38 and backend == "ACS" || bandwidth == 12.5 and bandwidthByWindows>= 1.52 and backend = "ACS" else 1.235 if backend = "ACS" else getK1(backend)   #TODO

#k2                     = 1.21 if backend == "ACS" else #getK2(backend)##TODO define in models
sensitivityS_withRef   = ((2*k_boltz*k1*estTS)/(efficiency*math.pi*math.pow(DishRadius,2))*math.sqrt(((RSigRef+nRefSmthAvrg )*(RSigRef +1))/(k2*math.pow(10,6)*bw*n_uncorr_samp*RSigRef*nRefSmthAvrg*tTotal)))
sensitivityS           = sensitivityS_withRef
sensitivityS_withOutRef    = ((2*k_boltz*k1*estTS)/(efficiency*math.pi*math.pow(DishRadius,2))*math.sqrt(1/(k2*math.pow(10,6)*bw*n_uncorr_samp*tTotal)))
sensitivityTA          = (efficiency * math.pi * math.pow(DishRadius,2)*sensitivityS)/(2*k_boltz * attenuation)
sensitivityTR          = (attenuation * sensitivityTA) / (efficiency)
tTotal                 = tTotal_withRef if differenceSignal and conversion == "sensitivity" else tTotal_withOutRef if conversion == "sensitivity" else time
tTotal_withOutRef      = math.pow(((2*k_boltz*k1*estTS)/(efficiency * math.pi *math.pow(DishRadius,2) * sensitivityS)),2)*(1/(k2*106*bw*n_uncorr_samp))
tTotal_withRef         = math.pow(((2*k_boltz*k1*estTS)/(efficiency * math.pi *math.pow(DishRadius,2) * sensitivityS)),2)*(((RSigRef+nRefSmthAvrg)*(RSigRef+1))/(k2*106*bw*n_uncorr_samp*RSigRef*nRefSmthAvrg))
fwhm                   = cc * ( wavelength / ( 2 * DishRadius))
wavelength             = c/frequency
c                      = 2.99792458e5
f_theta                = 1 / (1 + math.pow((size/fwhm),2))
observing_method       = 1
efficiency_track       = 1 if topo_freq < 2 or topo_freq > 50 else getTrack(semester, topo_freq)#TODO
efficiency_surf        = 1 if topo_freq < 2 or topo_freq > 50 else getTrack(semester, topo_freq)#TODO
efficiency_atm         = 1 if topo_freq < 2 or topo_freq > 50 else getATM(semester, topo_freq)
efficiency_DSS         = efficiency_surf * efficiency_track * efficiency_atm
tau_0                  = getTau_0(semester, topo_freq)
tATM                   = tATM_a
estTC                  = (tBG + tGalBG) / math.sqrt(efficiency_track * efficiency_surf) + (est0 / efficiency_DSS) 
min_velocity_resolution   = abs(velocity_resolution_1-velocity_resolution_2)
frequency_resolution   = bw/channels*100 if backend == "ACS" or "SP" else 1
frequency              = topo_freq
#bandWidthByWindows     = bandwidth/windows
aperture_efficiency    = efficiency_0 * math.exp(-math.pow((1.45 * math.pow(10,-5) * frequency ),2))
timeToSet              = rads * math.acos((math.sin( Elev_min / rads) - math.sin( alat / rads ) * math.sin( declination / rads )) / (math.cos(alat / rads) * math.cos(declination/rads))) / 15
rads                   = 57.2957795130823
alat                   = 38.25
#sensitivity_n_overlap = 1 if backend != "Spectral Processor" else #getSesitivity_n_overlap(backend,n_overlap, level)TODO
f_phi_1                = frequency+ min_topo_frequency/2
f_phi_2                = frequency- min_topo_frequency/2
velocity_resolution_1  = 1
#velocity_resolution_1 = f_phi_1-topo_freq/topo_freq if doppler=="redshift" else c*f_phi_1-topo_freq/f_phi_1 if doppler=="radio" else c*f_phi_1-topo_freq/topo_freq if doppler=="optical" else c*math.sqrt(f_phi_1,2)-math.pow(topo_freq,2))/(math.pow(topo_freq,2)+math.pow(f_phi_1,2))
velocity_resolution_2 = 1
#velocity_resolution_2 = f_phi_2-topo_freq/topo_freq if doppler=="redshift" else c*f_phi_2-topo_freq/f_phi_1 if doppler=="radio" else c*f_phi_2-topo_freq/topo_freq if doppler=="optical"  else c*math.sqrt(f_phi_2,2)-math.pow(topo_freq,2))/(math.pow(topo_freq,2)+math.pow(f_phi_2,2))
resolution             = topo_freq
min_resolution         = min_topo_frequency
bandwidth_resolution   = abs(resolution_1-resolution_2)
resolution_1           = velocity_smoothing_resolution_1 if ResolutionSmoothing == "velocityRes" else topo_resolution_1 if ResolutionSmoothing =="topoRes" else rest_resolution_1
velocity_smoothing_resolution_2  = (frequency/(1+phi_2) if doppler == "redshift" else frequency/(1+phi_2/c) if doppler == "optical" else frequency*(1+phi_2/c) if doppler == "radio" else frequency*math.sqr(1-math.pow(phi_2/c))) 
topo_resolution_2      = c*(phi_2-topo_freq)/topof_freq
rest_resolution_2      = c*(math.pow(phi_2,2)-math.pow(rest_freq,2))/(math.pow(rest_freq,2)+math.pow(phi_2,2))
phi_1                  = resolution + min_topo_frequency/2
phi_2                  = resolution - min_topo_frequency/2

[units]
resolution          = km/s
topo_frea           = GHz
min_topo_freq       = kHz
time                = sec
sensitivity         = Jy
bandwidth           = MHz
min_topo_frequency  = GHz
declination         = degrees
rest_freq           = GHz
source_velocity     = km/s
size                = Arc Minutes
rightAscension      = degrees
tBG                 = K
bw                  = kHz
bwRef               = MHz
c                   = km/s
